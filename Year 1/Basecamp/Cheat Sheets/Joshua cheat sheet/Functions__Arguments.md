> [!info] Reference
> [[Introducing Python - Book]] - Chapter 9.
## Define a function with `def function_name():`
## Call a function with `function_name()`
## Keyword arguments
- Causes position of arguments to not matter
``` Python
>>> def menu(wine, entree, dessert):
...     print(f"{wine} {entree} {desert}")

>>> menu(entree="Beef", dessert="Bagel", wine="Bordeaux")
'Bordeaux Beef Bagel'
```
## Default parameter values
``` Python
>>> def function(arg1, arg2, arg3="Hello"):
...     pass
```
## Gather/Explode positional arguments with `*`
- `*` groups a variable number of positional arguments into a single tuple of parameter values.
- Note the output when exploding `args`.
``` Python
>>> def print_args(*args):
...     print(args)

# Gathering
>>> print_args(3, 2, 1, "Hello")
(3, 2, 1, 'Hello')

# Exploding
>>> args = (3, 2, 1, "Hello")
>>> print_args(args)
((3, 2, 1, 'Hello'),)
```
## Gather/Explode keyword arguments with `**`
- `**` groups keyword arguments into a dictionary, where the argument names are the keys, and their values are the corresponding dictionary values.
``` Python
>>> def print_kwargs(**kwargs):
...     print(kwargs)

>>> print_kwargs(arg1="Hello", arg2="Goodbye")
{'arg1': 'Hello', 'arg2': 'Goodbye'}
```
## Keyword-only arguments
- The single `*` in the function definition means that the following parameters `start` and `end` must be provided as named arguments if we don't want their default values.
``` Python
>>> def print_data(data, *, start=0, end=100):
...     for value in (data[start:end]):
...         print(value)

>>> data = ["a", "b", "c", "d", "e", "f"]
>>> print_data(data)
a
b
c
d
e
f
>>> print_data(data, start=4)
e
f
>>> print_data(end=2)
a
b
```
## Docstrings
- You can attach documentation to a function by including a string at the beginning of the function body. This is the function's *docstring*.
- You can then use `help()` to show the docstring.
``` Python
>>> def echo(arg1)
...     `this function returns its input argument`
...     return arg1

>>> help(echo)
Help on function echo in module __main__:

echo(arg1)
    echo returns its input argument

>>>
```
## Functions can be used as arguments
``` Python
>>> def answer():
...     print(42)

>>> def run_something(func)
...     func()

>>> run_something(answer)
42
```
## Nested functions
``` Python
>>> def outer(a, b):
...     def inner(c, d):
...         return c + d
...     return inner(a, b)

>>> outer(4, 7)
11
```
## Closures
- An inner function can act as a *closure*. This is a function what is dynamically generated by another function and can both change and remember the values of variables that were created outside the function.
- Note the way their values are stored and called.
``` Python
>>> def say(text):
...     def inner():
...         return f"Say: {text}"
...     return inner

>>> a = say("Hello")
>>> a()
'Say: Hello'
```

## Lambda functions
- An anonymous function expressed as a single statement.
``` Python
# Normal function
>>> def print_list(list, func):
...     for item in list:
...         print(f"{func(item)}")

>>> def capital(word):
...     return word.capitalize() + "!"

>>> sounds = ["meow", "woof"]

>>> print_list(sounds, capital)
Meow!
Woof!


# Lambda function
>>> print_list(sounds, lambda item: item.capitalize() + "!")
Meow!
Woof!
```
## Generators
- A *generator* is a Python sequence creation object.
- Every time you iterate through a generator, it keeps track of where it was the last time it was called and returns the next value.
- If you want to create a potentially large sequence, you can write a *generator function*. It's a normal function but it returns its value with `yield` instead of `return`.
``` Python
>>> def my_range(first=0, last=10, step=1):
...     number = first
...     while number < last:
...         yield number
...         number += step

>>> a = my_range(1, 5)
>>> a
<generator object my_range at 0x1234>

>>> for x in a:
...     print(x)
1
2
3
4
```
## Generator comprehensions
- Similar to a comprehension for [[Tuples & Lists|lists]], [[Dictionaries & Sets|dictionaries]] and [[Dictionaries & Sets|sets]]. But is surrounded by parentheses instead of square or curly brackets.
``` Python
>>> genobj = (pair for pair in zip(['a', 'b'], ['1', '2']))
>>> genobj
<generator object <genexpr> at 0x1234>

>>> for thing in genobj:
...     print(thing)
('a', '1')
('b', '2')
```
## Decorators
- A *decorator* is a function that takes one function as input and returns another function.
``` Python
>>> def document_it(func):
...     def new_function(*args, **kwargs):
...         print("Function name: ", func.__name__)
...         print("Positional arguments: ", args)
...         print("Keyword arguments: ", kwargs)
...         result = func(*args, **kwargs)
...         print("Result: ", result)
...         return result
...     return new_function

>>> def add(a, b):
...    return a + b

>>> documented_add = document_it(add)
>>> documented_add(3, 5)
Function name: add
Positional arguments: (3, 5)
Keyword arguments: {}
Result: 8
8
```
## Create your own exception
``` Python
>>> class UppercaseException(Exception):
...     pass

>>> raise UppercaseException("WORD")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UppercaseException: WORD
```